import { describe, it, expect, beforeEach, vi } from 'vitest';
import { validateURL } from '../../utils/validateURL.js';
import { checkStreamOnline } from '../../utils/checkStreamOnline.js';
import { genres } from '../../utils/genres.js';
import { cache } from '../../utils/cache.js';
import { database } from '../../utils/database.js';

// Mock des modules
vi.mock('winston', () => ({
  createLogger: vi.fn(() => ({
    info: vi.fn(),
    error: vi.fn(),
    warn: vi.fn(),
    debug: vi.fn()
  })),
  format: {
    combine: vi.fn(),
    timestamp: vi.fn(),
    errors: vi.fn(),
    json: vi.fn(),
    colorize: vi.fn(),
    simple: vi.fn()
  },
  transports: {
    Console: vi.fn(),
    File: vi.fn()
  }
}));

vi.mock('better-sqlite3', () => ({
  default: vi.fn(() => ({
    prepare: vi.fn(() => ({
      run: vi.fn(),
      get: vi.fn(),
      all: vi.fn()
    })),
    close: vi.fn()
  }))
}));

describe('Utils Integration Tests', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('URL Validation', () => {
    it('should validate YouTube URLs', () => {
      const validYouTubeURLs = [
        'https://www.youtube.com/watch?v=dQw4w9WgXcQ',
        'https://youtu.be/dQw4w9WgXcQ',
        'https://youtube.com/watch?v=dQw4w9WgXcQ',
        'https://m.youtube.com/watch?v=dQw4w9WgXcQ'
      ];

      validYouTubeURLs.forEach(url => {
        expect(validateURL(url)).toBe(true);
      });
    });

    it('should validate Spotify URLs', () => {
      const validSpotifyURLs = [
        'https://open.spotify.com/track/4iV5W9uYEdYUVa79Axb7Rh',
        'https://open.spotify.com/album/4iV5W9uYEdYUVa79Axb7Rh',
        'https://open.spotify.com/playlist/37i9dQZF1DXcBWIGoYBM5M'
      ];

      validSpotifyURLs.forEach(url => {
        expect(validateURL(url)).toBe(true);
      });
    });

    it('should reject invalid URLs', () => {
      const invalidURLs = [
        'not-a-url',
        'http://invalid-domain.com',
        'https://youtube.com/invalid',
        'https://spotify.com/invalid',
        'ftp://example.com/file.mp3'
      ];

      invalidURLs.forEach(url => {
        expect(validateURL(url)).toBe(false);
      });
    });

    it('should handle edge cases', () => {
      expect(validateURL('')).toBe(false);
      expect(validateURL(null)).toBe(false);
      expect(validateURL(undefined)).toBe(false);
      expect(validateURL('https://youtube.com')).toBe(false); // Missing video ID
    });
  });

  describe('Stream Online Check', () => {
    it('should handle valid stream URLs', async () => {
      // Mock successful stream check
      global.fetch = vi.fn().mockResolvedValue({
        ok: true,
        status: 200,
        json: () => Promise.resolve({ isLive: true })
      });

      const result = await checkStreamOnline('https://twitch.tv/testuser');
      expect(result).toBe(true);
    });

    it('should handle offline streams', async () => {
      // Mock offline stream
      global.fetch = vi.fn().mockResolvedValue({
        ok: true,
        status: 200,
        json: () => Promise.resolve({ isLive: false })
      });

      const result = await checkStreamOnline('https://twitch.tv/testuser');
      expect(result).toBe(false);
    });

    it('should handle network errors', async () => {
      // Mock network error
      global.fetch = vi.fn().mockRejectedValue(new Error('Network error'));

      const result = await checkStreamOnline('https://twitch.tv/testuser');
      expect(result).toBe(false);
    });

    it('should handle invalid URLs', async () => {
      const result = await checkStreamOnline('invalid-url');
      expect(result).toBe(false);
    });
  });

  describe('Genres', () => {
    it('should have valid genre structure', () => {
      expect(Array.isArray(genres)).toBe(true);
      expect(genres.length).toBeGreaterThan(0);
    });

    it('should have unique genre names', () => {
      const genreNames = genres.map(genre => genre.name);
      const uniqueNames = new Set(genreNames);
      expect(uniqueNames.size).toBe(genreNames.length);
    });

    it('should have valid genre objects', () => {
      genres.forEach(genre => {
        expect(genre).toHaveProperty('name');
        expect(genre).toHaveProperty('emoji');
        expect(typeof genre.name).toBe('string');
        expect(typeof genre.emoji).toBe('string');
        expect(genre.name.length).toBeGreaterThan(0);
        expect(genre.emoji.length).toBeGreaterThan(0);
      });
    });

    it('should find genres by name', () => {
      const rockGenre = genres.find(genre => genre.name.toLowerCase().includes('rock'));
      expect(rockGenre).toBeDefined();
      expect(rockGenre).toHaveProperty('name');
      expect(rockGenre).toHaveProperty('emoji');
    });
  });

  describe('Cache System', () => {
    it('should set and get cache values', () => {
      const key = 'test-key';
      const value = { data: 'test-value', timestamp: Date.now() };

      cache.set(key, value);
      const retrieved = cache.get(key);

      expect(retrieved).toEqual(value);
    });

    it('should handle cache expiration', () => {
      const key = 'expiring-key';
      const value = { data: 'expiring-value', timestamp: Date.now() };

      cache.set(key, value, 1); // 1ms expiration

      // Wait for expiration
      return new Promise(resolve => {
        setTimeout(() => {
          const retrieved = cache.get(key);
          expect(retrieved).toBeNull();
          resolve();
        }, 10);
      });
    });

    it('should clear cache entries', () => {
      const key = 'clear-key';
      const value = { data: 'clear-value' };

      cache.set(key, value);
      cache.clear(key);

      const retrieved = cache.get(key);
      expect(retrieved).toBeNull();
    });

    it('should handle cache statistics', () => {
      const stats = cache.getStats();

      expect(stats).toHaveProperty('size');
      expect(stats).toHaveProperty('hits');
      expect(stats).toHaveProperty('misses');
      expect(typeof stats.size).toBe('number');
      expect(typeof stats.hits).toBe('number');
      expect(typeof stats.misses).toBe('number');
    });

    it('should handle concurrent cache access', async () => {
      const key = 'concurrent-key';
      const value = { data: 'concurrent-value' };

      // Simulate concurrent access
      const promises = [];
      for (let i = 0; i < 10; i++) {
        promises.push(
          new Promise(resolve => {
            cache.set(key, { ...value, index: i });
            const retrieved = cache.get(key);
            resolve(retrieved);
          })
        );
      }

      const results = await Promise.all(promises);
      results.forEach(result => {
        expect(result).toBeDefined();
        expect(result).toHaveProperty('data');
      });
    });

    it('should handle cache operations', async () => {
      const cache = new Map();

      // Test set
      cache.set('test-key', 'test-value');
      expect(cache.get('test-key')).toBe('test-value');

      // Test delete
      cache.delete('test-key');
      expect(cache.get('test-key')).toBeUndefined();

      // Test clear
      cache.set('key1', 'value1');
      cache.set('key2', 'value2');
      cache.clear();
      expect(cache.size).toBe(0);
    });

    it('should handle cache expiration', async () => {
      const cache = new Map();
      const expirationTime = 1000; // 1 second

      cache.set('expiring-key', {
        value: 'test-value',
        expiresAt: Date.now() + expirationTime
      });

      // Should exist before expiration
      expect(cache.get('expiring-key')).toBeDefined();

      // Wait for expiration
      await new Promise(resolve => setTimeout(resolve, expirationTime + 100));

      // Should be expired
      const entry = cache.get('expiring-key');
      expect(entry.expiresAt).toBeLessThan(Date.now());
    });
  });

  describe('Database', () => {
    it('should initialize database connection', async () => {
      // Test database initialization
      expect(database).toBeDefined();
    });

    it('should handle database queries', async () => {
      // Mock database query
      const mockQuery = vi.fn().mockReturnValue({
        all: vi.fn().mockResolvedValue([]),
        get: vi.fn().mockResolvedValue(null),
        run: vi.fn().mockResolvedValue({ changes: 0 })
      });

      // Test query execution
      expect(mockQuery).toBeDefined();
    });

    it('should handle database errors gracefully', async () => {
      // Mock database error
      const mockError = new Error('Database connection failed');

      // Test error handling
      expect(mockError).toBeInstanceOf(Error);
      expect(mockError.message).toBe('Database connection failed');
    });

    it('should handle database queries', async () => {
      const mockDb = {
        prepare: vi.fn(() => ({
          run: vi.fn().mockReturnValue({ lastInsertRowid: 1 }),
          get: vi.fn().mockReturnValue({ id: 1, name: 'test' }),
          all: vi.fn().mockReturnValue([{ id: 1, name: 'test' }])
        })),
        close: vi.fn()
      };

      // Test insert
      const insertStmt = mockDb.prepare('INSERT INTO test (name) VALUES (?)');
      const insertResult = insertStmt.run('test-name');
      expect(insertResult.lastInsertRowid).toBe(1);

      // Test select
      const selectStmt = mockDb.prepare('SELECT * FROM test WHERE id = ?');
      const selectResult = selectStmt.get(1);
      expect(selectResult.name).toBe('test');

      // Test select all
      const selectAllStmt = mockDb.prepare('SELECT * FROM test');
      const selectAllResult = selectAllStmt.all();
      expect(selectAllResult).toHaveLength(1);
    });

    it('should handle database errors', async () => {
      const mockDb = {
        prepare: vi.fn(() => ({
          run: vi.fn().mockImplementation(() => {
            throw new Error('Database error');
          }),
          get: vi.fn(),
          all: vi.fn()
        })),
        close: vi.fn()
      };

      const stmt = mockDb.prepare('INSERT INTO test (name) VALUES (?)');

      try {
        stmt.run('test-name');
      } catch (error) {
        expect(error.message).toBe('Database error');
      }
    });
  });

  describe('Utils Integration', () => {
    it('should work together in a typical workflow', async () => {
      // Simulate a typical workflow: validate URL -> check stream -> cache result
      const url = 'https://www.youtube.com/watch?v=dQw4w9WgXcQ';

      // Step 1: Validate URL
      const isValidURL = validateURL(url);
      expect(isValidURL).toBe(true);

      // Step 2: Check if it's a stream
      const isStream = url.includes('twitch.tv') || url.includes('youtube.com/live');
      expect(typeof isStream).toBe('boolean');

      // Step 3: Cache the result
      const cacheKey = `url_${Buffer.from(url).toString('base64')}`;
      const cacheValue = {
        url,
        isValid: isValidURL,
        isStream,
        timestamp: Date.now()
      };

      cache.set(cacheKey, cacheValue, 300000); // 5 minutes

      // Step 4: Retrieve from cache
      const cached = cache.get(cacheKey);
      expect(cached).toEqual(cacheValue);
    });

    it('should handle error scenarios gracefully', async () => {
      // Test error handling across utilities
      const invalidURL = 'invalid-url';

      // Should handle invalid URL
      expect(validateURL(invalidURL)).toBe(false);

      // Should handle stream check error
      const streamResult = await checkStreamOnline(invalidURL);
      expect(streamResult).toBe(false);

      // Should handle cache with invalid data
      cache.set('error-key', null);
      const cached = cache.get('error-key');
      expect(cached).toBeNull();
    });

    it('should maintain data consistency', () => {
      // Test data consistency across utilities
      const testData = {
        url: 'https://www.youtube.com/watch?v=dQw4w9WgXcQ',
        genre: genres[0],
        timestamp: Date.now()
      };

      // Cache the data
      cache.set('consistency-test', testData);

      // Retrieve and validate
      const retrieved = cache.get('consistency-test');
      expect(retrieved).toEqual(testData);
      expect(validateURL(retrieved.url)).toBe(true);
      expect(retrieved.genre).toHaveProperty('name');
      expect(retrieved.genre).toHaveProperty('emoji');
    });
  });

  describe('Error Handling', () => {
    it('should handle async errors', async () => {
      const asyncFunction = async () => {
        throw new Error('Async error');
      };

      try {
        await asyncFunction();
      } catch (error) {
        expect(error.message).toBe('Async error');
      }
    });

    it('should handle sync errors', () => {
      const syncFunction = () => {
        throw new Error('Sync error');
      };

      try {
        syncFunction();
      } catch (error) {
        expect(error.message).toBe('Sync error');
      }
    });

    it('should handle promise rejections', async () => {
      const promiseFunction = () => {
        return Promise.reject(new Error('Promise rejection'));
      };

      try {
        await promiseFunction();
      } catch (error) {
        expect(error.message).toBe('Promise rejection');
      }
    });
  });

  describe('Validation Utils', () => {
    it('should validate URLs', () => {
      const isValidUrl = url => {
        try {
          new URL(url);
          return true;
        } catch {
          return false;
        }
      };

      expect(isValidUrl('https://www.youtube.com/watch?v=test')).toBe(true);
      expect(isValidUrl('https://www.google.com')).toBe(true);
      expect(isValidUrl('invalid-url')).toBe(false);
      expect(isValidUrl('')).toBe(false);
    });

    it('should validate Discord IDs', () => {
      const isValidDiscordId = id => {
        return (/^\d{17,19}$/).test(id);
      };

      expect(isValidDiscordId('123456789012345678')).toBe(true);
      expect(isValidDiscordId('12345678901234567')).toBe(true);
      expect(isValidDiscordId('1234567890123456')).toBe(false);
      expect(isValidDiscordId('invalid-id')).toBe(false);
      expect(isValidDiscordId('')).toBe(false);
    });

    it('should validate command names', () => {
      const isValidCommandName = name => {
        return (/^[a-z-]+$/).test(name) && name.length <= 32;
      };

      expect(isValidCommandName('play')).toBe(true);
      expect(isValidCommandName('play-music')).toBe(true);
      expect(isValidCommandName('Play')).toBe(false);
      expect(isValidCommandName('play_music')).toBe(false);
      expect(isValidCommandName('')).toBe(false);
    });
  });

  describe('Formatting Utils', () => {
    it('should format duration', () => {
      const formatDuration = seconds => {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;

        if (hours > 0) {
          return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        return `${minutes}:${secs.toString().padStart(2, '0')}`;
      };

      expect(formatDuration(65)).toBe('1:05');
      expect(formatDuration(3661)).toBe('1:01:01');
      expect(formatDuration(0)).toBe('0:00');
    });

    it('should format file size', () => {
      const formatFileSize = bytes => {
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        if (bytes === 0) return '0 Bytes';
        const i = Math.floor(Math.log(bytes) / Math.log(1024));
        return `${Math.round((bytes / Math.pow(1024, i)) * 100) / 100  } ${  sizes[i]}`;
      };

      expect(formatFileSize(1024)).toBe('1 KB');
      expect(formatFileSize(1048576)).toBe('1 MB');
      expect(formatFileSize(0)).toBe('0 Bytes');
    });

    it('should truncate text', () => {
      const truncateText = (text, maxLength) => {
        if (text.length <= maxLength) return text;
        return `${text.substring(0, maxLength - 3)  }...`;
      };

      expect(truncateText('Short text', 20)).toBe('Short text');
      expect(truncateText('This is a very long text that needs to be truncated', 20)).toBe('This is a very lo...');
    });
  });

  describe('Performance Utils', () => {
    it('should measure execution time', async () => {
      const measureTime = async fn => {
        const start = Date.now();
        await fn();
        const end = Date.now();
        return end - start;
      };

      const testFunction = async () => {
        await new Promise(resolve => setTimeout(resolve, 100));
      };

      const executionTime = await measureTime(testFunction);
      expect(executionTime).toBeGreaterThanOrEqual(100);
    });

    it('should debounce functions', async () => {
      const debounce = (func, wait) => {
        let timeout;
        return function executedFunction (...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      };

      let callCount = 0;
      const debouncedFn = debounce(() => {
        callCount++;
      }, 100);

      debouncedFn();
      debouncedFn();
      debouncedFn();

      await new Promise(resolve => setTimeout(resolve, 150));
      expect(callCount).toBe(1);
    });
  });
});
